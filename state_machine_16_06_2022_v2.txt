#include <AccelStepper.h>
#include <Servo.h>

void findPlace();
void placeCard();
void error();
void takeCard_moveDown();
void takeCard_sucktion();
void takeCard_lift();

const int stepX = 2;
const int dirX = 5;
const int stepY = 3;
const int dirY = 6;
const int stepZ = 4;

const int dirZ = 7;
const int stepA = 12;
const int dirA = 13;

int endstop_sucktion_sensor = 48;   
int endstop_bottom_sensor = 50;    
int endstop_top_sensor = 52;         

bool check = false;
String terminal;
int machine_state = 2;
int main_state = 1;
int takeCard_state = 1;
int dropCard_state = 1;

float discHORIZONTALPositionSteps[7] = {87.5, 175, 262.5, 350, -262.5, -175, -87.5};
float discVERTICALPositionSteps[3] = {50, 100, 150};


String userInput;
String currentPlacement[2] = {"0", "0"};
String pickUpPlacement[2] = {"0", "0"};
String destination[2] = {"0", "0"};
String RESETcurrentPlacement[2] = {"0", "0"};

String dataFromRaspberryPi;
const char *seperator = ",";
char *token;
char charBuf[8];

#define handSwitch 5
Servo servo;
int pos = 0;
bool cardLifted = false;
bool movementDone = true;
bool messageProtocolOver;
bool computerVisionInitiated = false;



AccelStepper stepperX_TOP(AccelStepper::DRIVER, stepX, dirX); // Defaults to AccelStepper::FULL4WIRE    // Define a stepper and the pins it will use
AccelStepper stepperY_MIDDLE(AccelStepper::DRIVER, stepY, dirY); // Defaults to AccelStepper::FULL4WIRE 
AccelStepper stepperZ_BOTTOM(AccelStepper::DRIVER, stepZ, dirZ); // Defaults to AccelStepper::FULL4WIRE 
AccelStepper stepperA_SUCKTION(AccelStepper::DRIVER, stepA, dirA); // Defaults to AccelStepper::FULL4WIRE 
 
void setup()
{  

  stepperX_TOP.setMaxSpeed(0);             // used by run() - motor accelerates up to this value
  stepperX_TOP.setAcceleration(0);             
  stepperX_TOP.setCurrentPosition(0);        // Resets current position of motor to 0 position (also sets motor speed to 0) 

  stepperY_MIDDLE.setMaxSpeed(400);             // used by run() - motor accelerates up to this value
  stepperY_MIDDLE.setAcceleration(800);             
  stepperY_MIDDLE.setCurrentPosition(0);        // Resets current position of motor to 0 position (also sets motor speed to 0) 

  stepperZ_BOTTOM.setMaxSpeed(400);             // used by run() - motor accelerates up to this value
  stepperZ_BOTTOM.setAcceleration(800);             
  stepperZ_BOTTOM.setCurrentPosition(0);        // Resets current position of motor to 0 position (also sets motor speed to 0) 

  stepperA_SUCKTION.setMaxSpeed(900);             // used by run() - motor accelerates up to this value
  stepperA_SUCKTION.setAcceleration(1500);             
  stepperA_SUCKTION.setCurrentPosition(0);        // Resets current position of motor to 0 position (also sets motor speed to 0) 
  
  pinMode(endstop_bottom_sensor, INPUT);
  pinMode(endstop_top_sensor, INPUT);
  pinMode(endstop_sucktion_sensor, INPUT);

  pinMode(handSwitch, INPUT_PULLUP);
  servo.attach(46);
  servo.write(0);
  
  Serial.begin(115200);
}

void loop() {
 
  machine_state_machine();
 
}


void machine_state_machine() {

  switch(machine_state) {

  case 1: // INITIALIZE MACHINE
  
  break;
  case 2: // AWAIT COMMAND
  messageProtocolOver = false;
  serialCommunicationProtocol();
    
  break;
  case 3: // RUN MACHINE
   if (movementDone == true) {
    //userInputMovement();
    movementDone = false;
   }
  
  move_state_machine();
  machine_state = 2;
  break;
  case 4: // STOP MACHINE
  
  break;
  }
}


void move_state_machine() {
  switch(main_state)      // STATES: FIND CARD, TAKE CARD, FIND PLACE, PLACE CARD, ERROR
  {
    case 1:          
      Serial.println("STATE 1: FIND PICKUP");
      
      calculateVERTICALPath(pickUpPlacement);
      motorChangeHORIZONTALPosition(calculateHORIZONTALChangePosition(pickUpPlacement));
      
      main_state = 2;
      break;     
    case 2:          
      if (takeCard_state == 1) {
        Serial.println("STATE 2: TAKE CARD");
      }
      takeCard_state_machine();
      
      break;
    case 3:          
      Serial.println("STATE 3: FIND PLACEMENT");

      calculateVERTICALPath(destination);
      motorChangeHORIZONTALPosition(calculateHORIZONTALChangePosition(destination));

      main_state = 4;
      break;       
    case 4:
      if (computerVisionInitiated == false) {          
        if (dropCard_state == 1) {
          Serial.println("STATE 4: PLACE CARD");
        }
        dropCard_state_machine();
      } else {
        Serial.println("STATE 4: VISION");

        
      }
      break;
    case 5:          
      Serial.println("STATE 5: ERROR");
      break;
  }
}

void userInputMovement() {
    
    Serial.print("Current Placement: |");
    for (int i = 0; i < 2; i++) {
      Serial.print(currentPlacement[i]);
      Serial.print("|");
    }
    
    Serial.println("Please choose [Pick-up DISC Placement]");
    while (Serial.available() == 0) {}         
    userInput = Serial.readString(); 
    Serial.print("Input: ");
    Serial.println(userInput); 
    pickUpPlacement[0] = userInput;
    userInput = "";

    Serial.println("Please choose [Pick-up SLOT Placement]");
    while (Serial.available() == 0) {}         
    userInput = Serial.readString(); 
    Serial.print("Input: ");
    Serial.println(userInput); 
    pickUpPlacement[1] = userInput;
    userInput = "";

    Serial.println("Please choose [DISC Destination]");
    while (Serial.available() == 0) {}         
    userInput = Serial.readString();
    Serial.print("Input: ");
    Serial.println(userInput);  
    destination[0] = userInput;
    userInput = "";

    Serial.println("Please choose [SLOT Destination]");
    while (Serial.available() == 0) {}         
    userInput = Serial.readString();
    Serial.print("Input: ");
    Serial.println(userInput);  
    destination[1] = userInput;
    userInput = "";
}

void takeCard_state_machine() {
  
  switch(takeCard_state)      
  {
    case 1:        // MOVE DOWN NO CARD
      Serial.println("\tTake_Card sub-state 1: MOVE DOWN"); 
      takeCard_moveDownNOCARD();      
      break;
    case 2:        // SUCKTION 
      Serial.println("\tTake_Card sub-state 2: SUCKTION");   
      takeCard_sucktion(); 
      takeCard_state = 3;  
      break;
    case 3:        // LIFT   
      Serial.println("\tTake_Card sub-state 3: LIFT"); 
      takeCard_liftWITHCARD();     
      takeCard_state = 1;  
      main_state = 3;
      break; 
  }
}

void dropCard_state_machine() {

 switch(dropCard_state) {
        
    case 1:       // MOVE DOWN WITH CARD
      Serial.println("\tDrop_Card sub-state 1: MOVE DOWN WITH CARD"); 
      dropCard_moveDownWITHCARD();
      dropCard_state = 2;
      break;

    case 2:       // NO SUCKTION
      Serial.println("\tDrop_Card sub-state 2: NO SUCKTION"); 
      dropCard_releaseSucktion();
      dropCard_state = 3;
      break;

    case 3:       // MOVE UP
      Serial.println("\tDrop_Card sub-state 3: MOVE UP"); 
      dropCard_liftNOCARD();
      dropCard_state = 1;
      main_state = 1;
      machine_state = 2;
      movementDone = true;
      break;
  }
}

void takeCard_moveDownNOCARD() {
  Serial.println("\t\tMoves down no Card");
  stepperA_SUCKTION.move(-1000);
  while (stepperA_SUCKTION.currentPosition() != -1000) {
      stepperA_SUCKTION.run();
      if (digitalRead(endstop_bottom_sensor) == LOW) {
            Serial.println("\t\t\tSENSOR: bottom sensor activated");
            while(1) {}
        }
      else if (digitalRead(endstop_sucktion_sensor) == LOW) {
            Serial.println("\t\t\tSENSOR: sucktion sensor activated");
            takeCard_state = 2;
            break;      
        } 
      }
      stepperA_SUCKTION.setCurrentPosition(0);
    }

void dropCard_moveDownWITHCARD() {
  Serial.println("\t\tMoves down with Card");
  stepperA_SUCKTION.move(-400);
  while (stepperA_SUCKTION.currentPosition() != -400) {
      stepperA_SUCKTION.run();
      if (digitalRead(endstop_bottom_sensor) == LOW) {
            Serial.println("\t\t\tSENSOR: bottom sensor activated");
            while(1) {}
      }
   }
   stepperA_SUCKTION.setCurrentPosition(0);
}


void takeCard_sucktion() {
    Serial.println("\t\tSucktion activating");
    for (pos = 0; pos <= 120; pos += 1) { // goes from 0 degrees to 180 degrees
      // in steps of 1 degree
      servo.write(pos);              // tell servo to go to position in variable 'pos'
      delay(15);                       // waits 15ms for the servo to reach the position
    }
    Serial.println("\t\tSucktion complete");
}

void dropCard_releaseSucktion() {
  Serial.println("\t\tRelease sucktion activated");
  for (pos = 120; pos != 0; pos -= 1) { // goes from 0 degrees to 180 degrees
      // in steps of 1 degree
      servo.write(pos);              // tell servo to go to position in variable 'pos'
      delay(15);                       // waits 15ms for the servo to reach the position  
  }
  Serial.println("\t\tRelease sucktion complete");
}

void takeCard_liftWITHCARD() {
   Serial.println("\t\tLift");
   stepperA_SUCKTION.move(800);
   while (stepperA_SUCKTION.currentPosition() != 800) {
      stepperA_SUCKTION.run();
      if (digitalRead(endstop_top_sensor) == LOW) {
            check = true;
            break;  
        } 
    }
   stepperA_SUCKTION.setCurrentPosition(0);   
}

void dropCard_liftNOCARD() {
   Serial.println("\t\tLift");
   stepperA_SUCKTION.move(400);
   while (stepperA_SUCKTION.currentPosition() != 400) {
      stepperA_SUCKTION.run();
      if (digitalRead(endstop_top_sensor) == LOW) {
            check = true;
            break;  
        } 
    }
    stepperA_SUCKTION.setCurrentPosition(0);  
}

int calculateHORIZONTALChangePosition(String inputDestination[2]) {

  int tmpHolder;
  float amountOfStepsHORIZONTAL;
  int distanceHORIZONTAL; 

  distanceHORIZONTAL = inputDestination[1].toInt() - currentPlacement[1].toInt();

  Serial.print("\n\tMOVING CURRENT DISC [");
  Serial.print(inputDestination[0]);
  Serial.println("]");

  Serial.println("\t\tCalculating Movement:");
  Serial.print("\t\tDestination: [");
  Serial.print(inputDestination[0]);
  Serial.print("|");
  Serial.print(inputDestination[1]);
  Serial.print("]");
  Serial.print("\t\tCurrent Placement: [");
  Serial.print(currentPlacement[0]);
  Serial.print("|");
  Serial.print(currentPlacement[1]);
  Serial.println("]");
  Serial.print("\t\tDistance: [");
  Serial.print(distanceHORIZONTAL);
  Serial.println("]");

  if (distanceHORIZONTAL < 0) {
    tmpHolder = -(distanceHORIZONTAL);
  } else {
    tmpHolder = distanceHORIZONTAL;
  }

  amountOfStepsHORIZONTAL = discHORIZONTALPositionSteps[tmpHolder - 1];

  if (distanceHORIZONTAL < 0) {
    amountOfStepsHORIZONTAL = amountOfStepsHORIZONTAL * -1;
  }
  
  Serial.print("\t\tCalculating Movement: Returning amount of steps: [");
  Serial.print(amountOfStepsHORIZONTAL);
  Serial.println("]");

  for (int i = 0; i < 2; i++) {
    currentPlacement[i] = inputDestination[i];
  }
  
  return amountOfStepsHORIZONTAL;
}



int calculateVERTICALChangePosition(String inputDestination[2]) {
  
  int distanceVERTICAL, amountOfStepsVERTICAL = 0;

  Serial.println("\n\tCHANGING DISCS");
  Serial.print("\t\tFrom Disc [");
  Serial.print(currentPlacement[0]);
  Serial.print("] to [");
  Serial.print(inputDestination[0]);
  Serial.println("]");
  

  if(inputDestination[0].toInt() < currentPlacement[0].toInt()) {
    distanceVERTICAL = inputDestination[0].toInt() - currentPlacement[0].toInt();
    distanceVERTICAL = -(distanceVERTICAL);

    amountOfStepsVERTICAL = discVERTICALPositionSteps[distanceVERTICAL];
    amountOfStepsVERTICAL = -(amountOfStepsVERTICAL);
  } else {
    distanceVERTICAL = inputDestination[0].toInt() - currentPlacement[0].toInt();
    
    amountOfStepsVERTICAL = discVERTICALPositionSteps[distanceVERTICAL];
  }
  
  Serial.print("\t\tCalculating Movement: Returning amount of steps: [");
  Serial.print(amountOfStepsVERTICAL);
  Serial.println("]");

  currentPlacement[0] = inputDestination[0];
  
  return amountOfStepsVERTICAL;
}


void motorChangeHORIZONTALPosition(int amountOfSteps) {
  
  switch(currentPlacement[0].toInt()) {

    case 0:
      Serial.println("\t\t\t- Using StepperMotor BOTTOM [0]");
      stepperZ_BOTTOM.move(amountOfSteps);
      while (stepperZ_BOTTOM.currentPosition() != amountOfSteps) {
        stepperZ_BOTTOM.run();
      }  
      stepperZ_BOTTOM.setCurrentPosition(0);          
    
    break;
    case 1:
      Serial.println("\t\t\t- Using StepperMotor MIDDLE [1]");
      stepperY_MIDDLE.move(amountOfSteps);
      while (stepperY_MIDDLE.currentPosition() != amountOfSteps) {
        stepperY_MIDDLE.run();
      }  
      stepperY_MIDDLE.setCurrentPosition(0); 
    break;
    case 2:
      Serial.println("\t\t\t- Using StepperMotor TOP [2]");
      stepperX_TOP.move(amountOfSteps);
      while (stepperX_TOP.currentPosition() != amountOfSteps) {
        stepperX_TOP.run();
      }  
      stepperX_TOP.setCurrentPosition(0); 
    break;
  }    
  Serial.print("\n\t\t!New Current Placement: [");
  Serial.print(currentPlacement[0]);
  Serial.print("|");
  Serial.print(currentPlacement[1]);
  Serial.println("]");
      
}

void motorChangeVERTICALPosition(int amountOfSteps) {
  stepperA_SUCKTION.move(amountOfSteps);
    while (stepperA_SUCKTION.currentPosition() != amountOfSteps) {
      stepperA_SUCKTION.run();
    }
  stepperA_SUCKTION.setCurrentPosition(0);
}

void calculateVERTICALPath(String inputDestination[2]) {

    if (inputDestination[0] != currentPlacement[0]) {

       Serial.println("\n\t-! Initiating Disc Change !-");

       RESETcurrentPlacement[0] = currentPlacement[0];
       
       motorChangeHORIZONTALPosition(calculateHORIZONTALChangePosition(RESETcurrentPlacement));
       
       motorChangeVERTICALPosition(calculateVERTICALChangePosition(inputDestination));

       Serial.println("\n\t-! Disc Change Complete !-");
      
    }
}

void serialCommunicationProtocol() {
    
    char *tmpHolderPTR;

    if (dataFromRaspberryPi == "CONFIRMED") {

        pickUpPlacement[0] = charBuf[0];
        pickUpPlacement[1] = charBuf[2];
        destination[0] = charBuf[4];
        destination[1] = charBuf[6];

        if (destination[0] == 0 && destination[1] == 0) {
          Serial.println("UNKNOWN CARD REQUESTED");
          Serial.println("Camera Vision to be initialized");
          computerVisionInitiated = true;
        }
        
        //dataFromRaspberryPi = "";
        messageProtocolOver = true;
        machine_state = 3;
        
    } else if (dataFromRaspberryPi == "INCORRECT") {
      Serial.print("RETRY"); // ASK RASPBERRY TO RESTART PROTOCOL
    } else {
      Serial.println(dataFromRaspberryPi); // SEND DATA FOR CONFIRMATION
    }
    
    if (messageProtocolOver != true) {

      dataFromRaspberryPi.toCharArray(charBuf, 8);
      
      while (Serial.available() == 0) {}
        dataFromRaspberryPi = Serial.readStringUntil('\n');
        Serial.print("I have read the following: ");
        Serial.println(dataFromRaspberryPi);
    }
}